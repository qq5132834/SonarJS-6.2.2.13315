<p>Reading a non-existent property on an object always returns <code>undefined</code>. Doing so is usually an error; either in the name of the
property or the type of the variable being accessed.</p>
<p>If an attempt is made to access properties of a primitive, the primitive is automatically encased in a primitive-wrapper object for the operation.
But being "promoted" to an object doesn't mean that the primitive will actually have properties to access. The wrapper object still won't have the
non-existent property and <code>undefined</code> will be returned instead. </p>
<p>This rule raises an issue when an attempt is made to access properties of a primitive. Thus this rule should only be activated when you don't use
monkey patching for standard objects, like <code>Number</code>, <code>Boolean</code> and <code>String</code>. </p>
<h2>Noncompliant Code Example</h2>
<pre>
x = 42;
y = x.length;   // Noncompliant, Number type doesn't have "length" property
</pre>
<h2>Exceptions</h2>
<p>The Ember framework introduces a few extensions to <code>String</code>. Since it is a widely used package, the following <code>String</code>
properties will not trigger this rule even though they are not built-in:</p>
<ul>
  <li> <code>camelize</code> </li>
  <li> <code>capitalize</code> </li>
  <li> <code>classify</code> </li>
  <li> <code>dasherize</code> </li>
  <li> <code>decamelize</code> </li>
  <li> <code>fmt</code> </li>
  <li> <code>loc</code> </li>
  <li> <code>underscore</code> </li>
  <li> <code>w</code> </li>
</ul>
<h2>Deprecated</h2>
<p>This rule is deprecated, and will eventually be removed.</p>

